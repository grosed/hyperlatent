library(snowboot)
library(igraph)
library(HyperG)

hypelst_to_graph <- function(elst, wght=TRUE){
    nd_ids = sort(unique(unlist(elst)))
    N = length(nd_ids)
    adj = matrix(0, N, N)
    for (i in 1:(N-1)){
        for (j in (i+1):N){
            e = sum(unlist(lapply(elst, function(x){ sum(c(nd_ids[i], nd_ids[j]) %in% x) == 2})))
            if (wght==TRUE){
                adj[i,j] = e
                adj[j,i] = e
            } else if (wght==FALSE){
                adj[i,j] = e > 0
                adj[j,i] = e > 0
            }
        }
    }
    return( adj )
}

hyp_conn_comp <- function(h){ # find connected components
    g = graph_from_adjacency_matrix(as.matrix(hypergraph_as_adjacency_matrix(h)), mode="undirected")
    comps = components(g)
    return( comps )
}

hyp_kcore <- function(h){ # find k core - VERY slow
    g = graph_from_adjacency_matrix(as.matrix(hypergraph_as_adjacency_matrix(h)), mode="undirected")
    core = coreness(g)
    kvals = unique(core)
    return( comps )
}

snowball_hypergraph_indices <- function(elst, input_seed = NA, nw = 2){
    ## elst is an edge list for a hypergraph

    ## create hypergraph
    h = hypergraph_from_edgelist(elst)
    ## convert to graph and define network object
    g = as.graph(h)
    degs = degree(g)
    N = vcount(g)
    net = list( edges = as_edgelist(g), degree = degs, n = N )

    ## snowball sample the graph
    if( is.na(input_seed) == TRUE ){
        seed = sample(1:N, 1, prob=degs/sum(degs))
    } else {
        seed = input_seed
    }
    sb = sample_about_one_seed(net, seed=seed, n.wave=nw )

    ## get list of newly added vertices as each wave
    sb_na = lapply(sb, unique)
    for (i in 2:length(sb_na)){
        sb_na[[i]] = setdiff( sb_na[[i]], unique(unlist(sb_na[1:(i-1)])) )
    }

    return( list(sb=sb, sb_na=sb_na, seed=seed) )
}

## instead try another method of network subsampling:
## this is a random walk sample, similar to description of 'Sampling from Large Graphs' in Sec 3.3.3
## first iteration of this function projected the hypergraph onto a graph - this doesnt work and can produce disconnected subsampled nodes if eg only ij of hyperedge ijk are sampled

sample_hyperedge_node <- function(elst, nd){
    ## extract hyperedges incident to nd
    es_adj_nd = elst[unlist(lapply(elst, function(x){ nd %in% x } ))]
    ## sample uniformly from hyperedges
    n_es_adj = length(es_adj_nd)
    smp_e = unlist(es_adj_nd[sample(1:n_es_adj, 1)])
    return(smp_e)
}

random_walk_subsample <- function(elst, seed, c_ret = 0.15, nmin = 50){
                                        # elst is an edge list for a hypergraph
                                        # seed is starting node
                                        # wght = T/F, whether projected graph is weights
                                        # c_ret is probability of returning to seed node
                                        # nmin is minimum length of newly sampled nodes

   
    ## determine random walk subsample
    nsmp = seed # start with seed node, append additional nodes later on

    while( length(nsmp) <= nmin ){
        ## sample random walk, at each stage can go back to the start with probability c_ret

        ## start at seed node, and set 'return index' to 0
        cur_seed = seed
        ret = 0 
        while( ret == 0 ){
            new_nds = sample_hyperedge_node(elst, cur_seed) 
            new_nds = new_nds[ new_nds != cur_seed ] # remove current seed node (included by default)
            ret = rbinom(1, 1, c_ret)
            cur_seed = new_nds[sample(length(new_nds), 1)]
            nsmp = append(nsmp, new_nds)
        }
        nsmp = unique(nsmp)
        print( length(nsmp) )
    }

    return( nsmp )
}

################################################################################################
## this is the snowball function I wrote previously, have found a package to make this neater
## do not use this function

## get_snowball <- function(elst, degs, ind, nMax){

##     icheck = c()
##     edge_smp = list()
    
##     ntot = 1
##     while (ntot <= nMax)
##     {

##         ## look through indexes in random order
##         shft = sample( 1:length(ind) )
##         ind = ind[shft] 

##         for (i in 1:length(ind)){
##             ## find edges which contain current index

##             ## don't want to subsample from same edge set repeatedly....
##             idin = unlist( lapply( 1:length(elst), function(j) {ind[i] %in% elst[[j]]} ) )
##             ein = elst[idin]

##             ## sample these edges according to degree
##             nedge = length(ein)
##             ## put a weight on each of these edges
##             dtmp = unlist(lapply( 1:nedge, function(j){ min(degs[ein[[j]]]) } ))
##             ptmp = dtmp/sum(dtmp) ## sample with these probabilities

##             smpl = sample( 1:nedge, sum(rbinom(nedge,1,.5)), replace=FALSE, prob=ptmp )
##             ## now I add some edges
##             edge_smp = append( edge_smp, ein[ smpl] ) ## storing the newly sampled edges
##             edge_smp = unique(edge_smp)
            

##             ## what is the break condition?
##             ## i am being really daft..
##             if ((ntot + length(unlist(edge_smp))) > nMax){
##                 ind = ind[1:i] 
##                 break
##             }
##         }
##         edge_smp = unique(edge_smp)
        
##         ## now I need to do some subtraction
##         icheck = append(icheck, ind) # these are the nodes I have 'checked'
##         ind = setdiff(unique( unlist(edge_smp) ), icheck) # make sure I am not rechecking an index
##         ntot = length( unique(unlist(edge_smp)) ) #length(icheck)
##         print(ntot)
##     }
##     return( edge_smp )
## }

## ## this is another attempt, I think this one is better
## getsubsample <- function(seed, W=3, prob=c(1,1,1)){
##                                         # seed is initial seed node
##                                         # W is number of waves
##                                         # prob is vector of length W, prob of acceptance in each wave
##                                         # return full edgelist, and edgelist from W-1 wave
    
##     ## set up lists to keep track
##     nodes_con = vector() # nodes that have been considered
##     eout = list() # edges in subsample

##     for (w in 1:W){

##         nseeds = length(seed) ## number of 'seed nodes'


##         ## find all edges including seed nodes
##         subsmp = elst[unlist(lapply( 1:length(elst), function(j){ sum(seed %in% elst[[j]] )}))>0]

##         ## remove edges including 'previous seed nodes' if not in first wave
##         if (length(nodes_con) >=1 ){
##             subsmp = subsmp[unlist(lapply(1:length(subsmp), function(j){sum(nodes_con %in% subsmp[[j]])}))==0]
##         }

##         ## accept edges with probability prob
##         nedge = length(subsmp)
##         subsmp = subsmp[ rbinom(nedge,1,prob[w])==1 ]

##         ## update eout
##         eout = append( eout, subsmp )
##         eout = lapply( eout, sort )
##         eout = unique( eout )
        
##         ## update nodes_con
##         nodes_con = append(nodes_con, seed)
        
##         ## find next wave of seed nodes
##         seed = setdiff( unique(unlist(eout)), nodes_con)

##         ## separate last wave
##         if (w == (W-1)){
##             eout_Wl1 = eout
##         }
##     }

##     ## find labels for larger sample (sort extra indices)
##     indext = setdiff( unique( unlist( eout) ), unique(unlist( eout_Wl1 ) ) )
##     newindext = sort( indext , index.return=TRUE )

##     ## relabel everything (start with smaller sample)
##     newind = sort( unique( unlist( eout_Wl1 ) ), index.return=TRUE )
##     eout_Wl1 = lapply( 1:length(eout_Wl1), function (j) {newind$ix[which( newind$x %in% eout_Wl1[[j]])]} )
##     Nsub = max( newind$ix )
    
##     ## now relabel the larger sample
##     for (i in 1:length(eout)){
##         ecur = eout[[i]]
##         idmatch = match( ecur, newind$x )
##         isna = is.na(idmatch)
##         for (j in 1:length(idmatch)){
##             if(isna[j]==TRUE){
##                 ecur[j] = newindext$ix[match( ecur[j], newindext$x )] + Nsub
##             } else {
##                 ecur[j] = newind$ix[match( ecur[j], newind$x )]
##             }
##         }
##         eout[[i]] = ecur
##     }

##     ## also calculate the degree of each node
##     Nsub = max(unique(unlist(eout_Wl1)))
##     degsub = rep(0, Nsub)
##     for (i in 1:Nsub){
##         degsub[i] = sum(unlist(lapply( 1:length(eout_Wl1), function(j){i %in% eout_Wl1[[j]]} )))
##     }

##     Nful = max(unique(unlist(eout)))
##     degful = rep(0, Nful)
##     for (i in 1:Nful){
##         degful[i] = sum(unlist(lapply( 1:length(eout), function(j){i %in% eout[[j]]} )))
##     }

##     ## return output from function
##     return(list(eFull=eout, eSub=eout_Wl1, degFull=degful, degSub=degsub, nSub=Nsub, nFull=Nful))
## }
